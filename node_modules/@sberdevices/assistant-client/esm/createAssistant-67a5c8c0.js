import { c as createNanoEvents, _ as __rest, a as __assign, b as __spreadArrays, p as proto } from './typings-79533271.js';

// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
// getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
// find the complete implementation of crypto (msCrypto) on IE11.
var getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);
var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

function rng() {
  if (!getRandomValues) {
    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
  }

  return getRandomValues(rnds8);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4

  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');
}

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof options == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }

  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

var createNanoObservable = function (observerFunc) {
    var _a = createNanoEvents(), on = _a.on, emit = _a.emit;
    var subscribe = function (_a) {
        var next = _a.next;
        var unsubscribe = on('next', next);
        return { unsubscribe: unsubscribe };
    };
    observerFunc({
        next: function (data) {
            emit('next', data);
        },
    });
    return {
        subscribe: subscribe,
    };
};

function inIframe() {
    try {
        return window.self !== window.top;
    }
    catch (e) {
        return true;
    }
}
if (typeof window !== 'undefined' && inIframe()) {
    var postMessage_1 = function (action) {
        var _a;
        (_a = window.top) === null || _a === void 0 ? void 0 : _a.postMessage(JSON.stringify(action), '*');
    };
    window.appInitialData = [];
    window.AssistantHost = {
        sendDataContainer: function (json) {
            postMessage_1({ type: 'sendDataContainer', payload: json });
        },
        close: function () {
            postMessage_1({ type: 'close' });
        },
        sendData: function (json) {
            postMessage_1({ type: 'sendData', payload: json });
        },
        setSuggests: function (suggests) {
            postMessage_1({ type: 'setSuggests', payload: suggests });
        },
        setHints: function (hints) {
            postMessage_1({ type: 'setHints', payload: hints });
        },
        ready: function () {
            postMessage_1({ type: 'ready' });
        },
        sendText: function (message) {
            postMessage_1({ type: 'sendText', payload: message });
        },
    };
    window.addEventListener('message', function (e) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        try {
            if (typeof e.data === 'string') {
                var data = JSON.parse(e.data);
                switch (data.type) {
                    case 'onData':
                        (_b = (_a = window.AssistantClient) === null || _a === void 0 ? void 0 : _a.onData) === null || _b === void 0 ? void 0 : _b.call(_a, data.payload);
                        break;
                    case 'onRequestState': {
                        var state = (_d = (_c = window.AssistantClient) === null || _c === void 0 ? void 0 : _c.onRequestState) === null || _d === void 0 ? void 0 : _d.call(_c);
                        postMessage_1({ type: 'state', payload: state, requestId: data.requestId });
                        break;
                    }
                    case 'onRequestRecoveryState': {
                        var recoverystate = (_f = (_e = window.AssistantClient) === null || _e === void 0 ? void 0 : _e.onRequestRecoveryState) === null || _f === void 0 ? void 0 : _f.call(_e);
                        postMessage_1({ type: 'recoveryState', payload: recoverystate });
                        break;
                    }
                    case 'onStart':
                        (_h = (_g = window.AssistantClient) === null || _g === void 0 ? void 0 : _g.onStart) === null || _h === void 0 ? void 0 : _h.call(_g);
                        break;
                    default:
                        // eslint-disable-next-line no-console
                        console.error(e, 'Unknown parsed message');
                        break;
                }
            }
        }
        catch (err) {
            // eslint-disable-next-line no-console
            console.error(err, 'Unknown message');
        }
    });
}
var createAssistant = function (_a) {
    var getState = _a.getState, getRecoveryState = _a.getRecoveryState, _b = _a.ready, ready = _b === void 0 ? true : _b;
    var currentGetState = getState;
    var currentGetRecoveryState = getRecoveryState;
    var isInitialDataReceived = false;
    var isInitialCommandsEmitted = false;
    /**
     * Стартовые команды на момент `window.AssistantClient.onStart()`.
     * Сохраняются однажды и не обновляются.
     * */
    var stackAppInitialData = [];
    /**
     * Стартовые команды, которые были получены методом `getInitialData()`.
     * Они не будут заэмичены при `window.AssistantClient.onStart()`.
     * */
    var receivedAppInitialData = [];
    var _c = createNanoEvents(), on = _c.on, emit = _c.emit;
    var observables = new Map();
    var emitCommand = function (command) {
        if (command.type === 'smart_app_data') {
            emit('command', command.smart_app_data);
        }
        if (command.type === 'smart_app_error') {
            emit('error', command.smart_app_error);
        }
        return emit('data', command);
    };
    var findSystemCommandIndex = function (command) {
        var _a, _b;
        var index = -1;
        if (command.type === 'character') {
            index = stackAppInitialData.findIndex(function (c) { return c.type === 'character' && c.character.id === command.character.id; });
        }
        else if (command.type === 'insets') {
            index = stackAppInitialData.findIndex(function (c) { return c.type === 'insets'; });
        }
        else if (command.type === 'app_context') {
            index = stackAppInitialData.findIndex(function (c) { return c.type === 'app_context'; });
        }
        else if (command.sdk_meta && ((_a = command.sdk_meta) === null || _a === void 0 ? void 0 : _a.mid) && ((_b = command.sdk_meta) === null || _b === void 0 ? void 0 : _b.mid) !== '-1') {
            index = stackAppInitialData.findIndex(function (c) { var _a, _b; return ((_a = c.sdk_meta) === null || _a === void 0 ? void 0 : _a.mid) === ((_b = command.sdk_meta) === null || _b === void 0 ? void 0 : _b.mid); });
        }
        return index;
    };
    var saveAppInitialData = function () {
        stackAppInitialData = __spreadArrays((window.appInitialData || []));
    };
    var isCommandWasReceived = function (command) {
        for (var _i = 0, receivedAppInitialData_1 = receivedAppInitialData; _i < receivedAppInitialData_1.length; _i++) {
            var receivedCommand = receivedAppInitialData_1[_i];
            if (receivedCommand === command) {
                return true;
            }
        }
        return false;
    };
    var emitAppInitialData = function () {
        if (!isInitialCommandsEmitted) {
            var currentInitialData = stackAppInitialData;
            var notReceivedCommands = isInitialDataReceived === true
                ? currentInitialData.filter(function (c) { return !isCommandWasReceived(c); })
                : currentInitialData;
            notReceivedCommands.forEach(function (c) { return emitCommand(c); });
            isInitialCommandsEmitted = true;
        }
    };
    window.AssistantClient = {
        onData: function (command) {
            var _a, _b, _c;
            var commandIndex = findSystemCommandIndex(command);
            var isCommandExist = commandIndex >= 0;
            if (isCommandExist) {
                stackAppInitialData.splice(commandIndex, 1);
                return;
            }
            /// фильтр команды 'назад'
            /// может приходить type='system', но в типах это не отражаем
            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
            // @ts-ignore
            if (command.type === 'system' && ((_b = (_a = command.system) === null || _a === void 0 ? void 0 : _a.command) === null || _b === void 0 ? void 0 : _b.toUpperCase()) === 'BACK') {
                return;
            }
            if ((command.type === 'smart_app_data' || command.type === 'smart_app_error') && ((_c = command.sdk_meta) === null || _c === void 0 ? void 0 : _c.requestId) &&
                observables.has(command.sdk_meta.requestId)) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                var _d = command.sdk_meta, realReqId = _d.requestId, meta = __rest(_d, ["requestId"]);
                var _e = observables.get(command.sdk_meta.requestId) || {}, requestId = _e.requestId, next = _e.next;
                if (Object.keys(meta).length > 0 || requestId) {
                    // eslint-disable-next-line @typescript-eslint/camelcase
                    command.sdk_meta = __assign({}, meta);
                    if (requestId) {
                        // eslint-disable-next-line @typescript-eslint/camelcase
                        command.sdk_meta = { requestId: requestId };
                    }
                }
                if (next) {
                    next(command.type === 'smart_app_data' ? command : command);
                }
                return;
            }
            emitCommand(command);
        },
        onRequestState: function () {
            return currentGetState();
        },
        onRequestRecoveryState: function () {
            if (currentGetRecoveryState) {
                return currentGetRecoveryState();
            }
            return undefined;
        },
        onStart: function () {
            emit('start');
            saveAppInitialData();
            emitAppInitialData();
        },
    };
    if (ready) {
        setTimeout(function () { var _a; return (_a = window.AssistantHost) === null || _a === void 0 ? void 0 : _a.ready(); }); // таймаут для подписки на start
    }
    var sendData = function (_a, onData) {
        var _b, _c, _d;
        var action = _a.action, name = _a.name, requestId = _a.requestId;
        if ((_b = window.AssistantHost) === null || _b === void 0 ? void 0 : _b.sendDataContainer) {
            if (onData == null) {
                (_c = window.AssistantHost) === null || _c === void 0 ? void 0 : _c.sendDataContainer(
                /* eslint-disable-next-line @typescript-eslint/camelcase */
                JSON.stringify({ data: action, message_name: name || '', requestId: requestId }));
                return function () { };
            }
            if (requestId && observables.has(requestId)) {
                throw new Error('requestId должен быть уникальным');
            }
            var subscribe = createNanoObservable(function (_a) {
                var _b;
                var next = _a.next;
                var realRequestId = requestId || v4();
                (_b = window.AssistantHost) === null || _b === void 0 ? void 0 : _b.sendDataContainer(
                /* eslint-disable-next-line @typescript-eslint/camelcase */
                JSON.stringify({ data: action, message_name: name || '', requestId: realRequestId }));
                observables.set(realRequestId, { next: next, requestId: requestId });
            }).subscribe;
            return subscribe({ next: onData }).unsubscribe;
        }
        if (onData != null) {
            throw new Error('Не поддерживается в данной версии клиента');
        }
        (_d = window.AssistantHost) === null || _d === void 0 ? void 0 : _d.sendData(JSON.stringify(action), name || null);
        return function () { };
    };
    return {
        close: function () { var _a; return (_a = window.AssistantHost) === null || _a === void 0 ? void 0 : _a.close(); },
        getInitialData: function () {
            isInitialDataReceived = true;
            receivedAppInitialData = __spreadArrays((window.appInitialData || []));
            return receivedAppInitialData;
        },
        findInInitialData: function (_a) {
            var type = _a.type, command = _a.command;
            var appInitialData = __spreadArrays((window.appInitialData || []));
            var result = appInitialData.find(function (data) {
                if (!command && type && type === data.type) {
                    return true;
                }
                var isCommandInSmartAppData = command && 'smart_app_data' in data;
                if (!isCommandInSmartAppData) {
                    return;
                }
                if (command === data.smart_app_data.command ||
                    command === data.smart_app_data.type) {
                    return true;
                }
                return false;
            });
            return (result && 'smart_app_data' in result ? result.smart_app_data : result);
        },
        getRecoveryState: function () { return window.appRecoveryState; },
        on: on,
        sendAction: function (action, onData, onError, _a) {
            var _b = _a === void 0 ? {} : _a, name = _b.name, requestId = _b.requestId;
            return sendData({ action: action, name: name, requestId: requestId }, function (data) {
                if (data.type === 'smart_app_data' && onData) {
                    onData(data.smart_app_data);
                    return;
                }
                if (data.type === 'smart_app_error' && onError) {
                    onError(data.smart_app_error);
                    return;
                }
                emitCommand(data);
            });
        },
        sendData: sendData,
        setGetState: function (nextGetState) {
            currentGetState = nextGetState;
        },
        setGetRecoveryState: function (nextGetRecoveryState) {
            currentGetRecoveryState = nextGetRecoveryState;
        },
        setSuggests: function (suggestions) {
            var _a;
            (_a = window.AssistantHost) === null || _a === void 0 ? void 0 : _a.setSuggests(JSON.stringify({ suggestions: { buttons: suggestions } }));
        },
        setHints: function (hints) {
            var _a;
            (_a = window.AssistantHost) === null || _a === void 0 ? void 0 : _a.setHints(JSON.stringify({ hints: hints }));
        },
        sendText: function (message) { var _a; return (_a = window.AssistantHost) === null || _a === void 0 ? void 0 : _a.sendText(message); },
        ready: function () { var _a; return (_a = window.AssistantHost) === null || _a === void 0 ? void 0 : _a.ready(); },
    };
};

export { createAssistant as c, v4 as v };
